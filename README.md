# 设计模式
### 面向对象设计的基本原则：
1、开闭原则（OCP：Open-Closed Priciple）:一个软件的实体应当对扩展开放，对修改关闭。

2、依赖到装原则（DIP：Dependence Inversion Priciple）：要针对接口编程，不要针对实现编程。

3、迪米特法则（LoD：Law of Demeter）：最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。只与你直接的朋友通信，而避免和陌生人通信

### 创建型模式
关注对象的创建过程

単例模式、工厂模式、抽象工厂模式、建造者模式、原型模式
### 结构型模式
关注对象和类的组织

适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
### 行为型模式
关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。

模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式


## 単例模式(singleton)
1、饿汉式（线程安全，调用效率高，但是不能延时加载）

2、懒汉式（线程安全，调用效率不高，但是可以延时加载）

3、双重检测锁式（由于JVM底层内部模型原因，偶尔会出现问题，不建议使用）

4、静态内部类式（线程安全，调用效率高，可以延时加载）

5、枚举単例（线程安全，调用效率高，但是不能延时加载，可以天然防止反射和反序列化漏洞）

对于反序列化漏洞，我们可以通过定义一个readResolve()方法来返回同一个对象

## 工厂模式(factory)
### 简单工厂(simple_factory)
也叫静态工厂，通过接收参数的不同返回不同的对象。

对于新增新产品无能为力，不修改代码，无法扩展。

**虽然某种程度不符合设计原则，但实际上使用最多**

### 工厂方法(factory_method)
创建一组工厂类，通过创建新的工厂类新增新产品，满足OCP。但容易造成类的数量膨胀

一般情况下，我们都使用简单工厂（只修改少量工厂类）

**不修改已有类的前提下，通过增加新的工厂类实现扩展**

### 抽象工厂(abstract_factory)
生产不同产品族的全部产品，对于增加新的产品无能为力，支持增加产品族。

**不可以增加产品，可以增加产品族**

## 建造者模式(builder)
分离了对象子组件的单独构造（由Builder来负责）和装配（由Director负责），从而可以构造出复杂的对象。

这个模式适用于某个对象的构建过程复杂的情况下使用。

## 原型模式(prototype)
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。（对象克隆）

需要实现Cloneable接口和clone方法。（深拷贝和浅拷贝）

浅拷贝后，前后两个对象中的对象属性并没有克隆，指向的还是同一个对象，改变其中一个，另一个也会跟着改变。

深拷贝后，前后两个对象中的所有属性都进行了克隆，两者完全不同。

还可以使用序列化和反序列化实现深拷贝。

## 适配器模式（adapter）
将一个类的接口转换成客户希望的另外一个接口。

目标接口（Target）：客户所期待的接口。可以是具体的或抽象的类，也可以是接口。

需要适配的类（Adaptee）：需要装配的类或适配者类。

适配器（Adapter）：通过包装一个需要适配的对象，把原有接口转换成目标接口。

类适配器方式（继承被适配类）和对象适配器方式（组合被适配类）

## 代理模式（proxy）
通过代理，控制对对象的访问。可以详细控制访问某个对象/类的方法，再调用这个方法前做前置处理，调用这个方法后做后置处理。（AOP的微观实现）

抽象角色：定义代理角色和展示角色的公共对外方法

真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。关注真正的业务逻辑。

代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
将统一的流程控制放到代理角色中处理。

静态代理（静态定义代理类）和动态代理（动态生成代理类：JDK、javasssist、CGLIB、ASM）

## 桥接模式（bridge）
处理多层继承结果，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。

桥接模式可以取代多层继承的方案。多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个数，从而降低管理和维护成本。

桥接模式极大的提到了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则。

## 组合模式（composite）
把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象

抽象（Component）构件角色：定义了叶子和容器构件的共同点

叶子（Leaf）构件角色：无子节点

容器（COmposite）构件角色：有容器特征，可以包含子节点

## 装饰模式（decorator）
也叫包装器模式（Wrapper）

动态的为一个对象增加新的功能

装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。

Component抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。

ConcreteComponent具体构件角色：真实对象

Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。

ConcreteDecorator：具体装饰角色：负责给构建对象增加新的责任。

装饰模式和桥接模式：两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。

## 外观模式（facade）
也叫门面模式

为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。

## 享元模式（flyweight）
享元模式以共享的方式高效地支持大量细粒度对象的重用。

享元对象能作到共享的关键是区分了内部状态和外部状态。内部状态：可以共享，不会随环境变化而变化。外部状态：不可以共享，会随环境变化而变化。

享元模式实现：
    
    1、FlyweithtFactory：享元工厂类：创建并管理享元对象，享元池一般设计成键值对。
    
    2、FlyWeight：抽象享元对象，通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
    
    3、COncreteFlyWeight：具体享元类，为内部状态提供成员变量进行存储。
    
    4、UnsharedConcreteFlyWeight:非共享享元类，不能内共享的子类可以设计为非共享享元类
    
优点：

    1、极大减少内存中对象的数量
    
    2、相同或相似的对象内存中只存一份，极大的节约资源，提高系统性能
    
    3、外部状态相对独立，不影响内部状态
    
缺点:

    1、模式较复杂，使程序逻辑复杂化
    
    2、为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。
    
## 责任链模式（chain Of responsibility）
将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。

链表方式定义责任链

非链表方式实现责任链:通过集合、数组生成责任链更加实用，实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以实用链表方式定义责任链就很困难。

