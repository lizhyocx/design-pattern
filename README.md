# 设计模式
### 面向对象设计的基本原则：
1、开闭原则（OCP：Open-Closed Priciple）:一个软件的实体应当对扩展开放，对修改关闭。

2、依赖到装原则（DIP：Dependence Inversion Priciple）：要针对接口编程，不要针对实现编程。

3、迪米特法则（LoD：Law of Demeter）：最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。只与你直接的朋友通信，而避免和陌生人通信

### 创建型模式
关注对象的创建过程

単例模式、工厂模式、抽象工厂模式、建造者模式、原型模式
### 结构型模式
关注对象和类的组织

适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
### 行为型模式
关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和协作，进一步明确对象的职责。

模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式


## 単例模式(singleton)
1、饿汉式（线程安全，调用效率高，但是不能延时加载）

2、懒汉式（线程安全，调用效率不高，但是可以延时加载）

3、双重检测锁式（由于JVM底层内部模型原因，偶尔会出现问题，不建议使用）

4、静态内部类式（线程安全，调用效率高，可以延时加载）

5、枚举単例（线程安全，调用效率高，但是不能延时加载，可以天然防止反射和反序列化漏洞）

对于反序列化漏洞，我们可以通过定义一个readResolve()方法来返回同一个对象

## 工厂模式(factory)
### 简单工厂(simple_factory)
也叫静态工厂，通过接收参数的不同返回不同的对象。

对于新增新产品无能为力，不修改代码，无法扩展。

**虽然某种程度不符合设计原则，但实际上使用最多**

### 工厂方法(factory_method)
创建一组工厂类，通过创建新的工厂类新增新产品，满足OCP。但容易造成类的数量膨胀

一般情况下，我们都使用简单工厂（只修改少量工厂类）

**不修改已有类的前提下，通过增加新的工厂类实现扩展**

### 抽象工厂(abstract_factory)
生产不同产品族的全部产品，对于增加新的产品无能为力，支持增加产品族。

**不可以增加产品，可以增加产品族**

## 建造者模式(builder)
分离了对象子组件的单独构造（由Builder来负责）和装配（由Director负责），从而可以构造出复杂的对象。

这个模式适用于某个对象的构建过程复杂的情况下使用。

## 原型模式(prototype)
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。（对象克隆）

需要实现Cloneable接口和clone方法。（深拷贝和浅拷贝）

浅拷贝后，前后两个对象中的对象属性并没有克隆，指向的还是同一个对象，改变其中一个，另一个也会跟着改变。

深拷贝后，前后两个对象中的所有属性都进行了克隆，两者完全不同。

还可以使用序列化和反序列化实现深拷贝。

## 适配器模式（adapter）
将一个类的接口转换成客户希望的另外一个接口。

目标接口（Target）：客户所期待的接口。可以是具体的或抽象的类，也可以是接口。

需要适配的类（Adaptee）：需要装配的类或适配者类。

适配器（Adapter）：通过包装一个需要适配的对象，把原有接口转换成目标接口。

类适配器方式（继承被适配类）和对象适配器方式（组合被适配类）

## 代理模式（proxy）
通过代理，控制对对象的访问。可以详细控制访问某个对象/类的方法，再调用这个方法前做前置处理，调用这个方法后做后置处理。（AOP的微观实现）

抽象角色：定义代理角色和展示角色的公共对外方法

真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。关注真正的业务逻辑。

代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。
将统一的流程控制放到代理角色中处理。

静态代理（静态定义代理类）和动态代理（动态生成代理类：JDK、javasssist、CGLIB、ASM）

## 桥接模式（bridge）
处理多层继承结果，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。

桥接模式可以取代多层继承的方案。多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个数，从而降低管理和维护成本。

桥接模式极大的提到了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则。

## 组合模式（composite）
把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象

抽象（Component）构件角色：定义了叶子和容器构件的共同点

叶子（Leaf）构件角色：无子节点

容器（COmposite）构件角色：有容器特征，可以包含子节点

## 装饰模式（decorator）
也叫包装器模式（Wrapper）

动态的为一个对象增加新的功能

装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。

Component抽象构件角色：真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰对象交互。

ConcreteComponent具体构件角色：真实对象

Decorator装饰角色：持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能。

ConcreteDecorator：具体装饰角色：负责给构建对象增加新的责任。

装饰模式和桥接模式：两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥接模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。

## 外观模式（facade）
也叫门面模式

为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用。

## 享元模式（flyweight）
享元模式以共享的方式高效地支持大量细粒度对象的重用。

享元对象能作到共享的关键是区分了内部状态和外部状态。内部状态：可以共享，不会随环境变化而变化。外部状态：不可以共享，会随环境变化而变化。

享元模式实现：
    
    1、FlyweithtFactory：享元工厂类：创建并管理享元对象，享元池一般设计成键值对。
    
    2、FlyWeight：抽象享元对象，通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。
    
    3、COncreteFlyWeight：具体享元类，为内部状态提供成员变量进行存储。
    
    4、UnsharedConcreteFlyWeight:非共享享元类，不能内共享的子类可以设计为非共享享元类
    
优点：

    1、极大减少内存中对象的数量
    
    2、相同或相似的对象内存中只存一份，极大的节约资源，提高系统性能
    
    3、外部状态相对独立，不影响内部状态
    
缺点:

    1、模式较复杂，使程序逻辑复杂化
    
    2、为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。
    
## 责任链模式（chain Of responsibility）
将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象。

链表方式定义责任链

非链表方式实现责任链:通过集合、数组生成责任链更加实用，实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以实用链表方式定义责任链就很困难。

## 迭代器模式（iterator）
提供一种可以遍历聚合对象的方式。又称为游标模式（cursor）

## 中介者模式（mediator）
如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系及其复杂，这些对象称为同事对象。我们可以引入一个中介者对象，使各个同时对象只跟中介者对象打交道，将复杂的网络结构化解为星形结构。

解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系。

## 命令模式（command）
也叫动作模式（Action）、事务模式（Transaction）

将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。

Receiver接收者：接收者执行与请求相关的操作，具体实现对请求的业务处理

Invoker调用者/请求者：请求的发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接调用接收者的相关操作。

## 解释器模式（interpreter）
用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计。

EL表达式的处理，正则表达式解释器，SQL语法解释器，数学表达式解析器

## 访问者模式（visitor）
对于存储在一个集合中的对象，他们可能具有不同的类型（即使有一个公共的接口），对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。

表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变元素的类的前提下定义作用于这些元素的新操作。

XML文档解析器设计，编译器设计，复杂集合对象的处理

## 策略模式（strategy）
对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法，并且由客户端决定调用哪个算法。




